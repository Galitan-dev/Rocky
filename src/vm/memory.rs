use std::{ops::Range};

// This file was generated by ChatGPT (after some discussion)

// I had given this struct
#[derive(Debug, Clone)]
pub struct MemoryHeap {
    data: Vec<u8>,
    partitions: Vec<Range<usize>>,
}

impl MemoryHeap {
    pub fn new(max_size: usize) -> Self {
        let mut memory_heap = MemoryHeap {
            data: Vec::new(),
            partitions: Vec::new(),
        };
        memory_heap.data.reserve(max_size);
        memory_heap
    }

    pub fn add(&mut self, bytes: Vec<u8>) -> usize {
        if self.data.len() + bytes.len() > self.data.capacity() {
            panic!("Memory heap exceeded maximum size");
        }
        let start = self.data.len();
        self.data.extend(bytes);
        let end = self.data.len();
        self.partitions.push(start..end);
        self.partitions.len() - 1
    }

    pub fn remove(&mut self, id: usize) {
        let range = &self.partitions.remove(id);
        self.delete(range.clone());
    }

    fn delete(&mut self, range: Range<usize>) {
        self.data.drain(range.clone());

        for partition in &mut self.partitions {
            if partition.start > range.end {
                *partition = partition.start - range.len()..partition.end - range.len();
            }
        }
    }

    // This was requested twice because the first time chatgpt didn't think about resizing partition
    pub fn edit(&mut self, bytes: Vec<u8>, id: usize) {
        if bytes.len() == self.get(id).len() {
            let range = self.partitions[id].clone();
            self.data.splice(range, bytes);
            return;
        }

        self.delete(self.partitions.get(id).unwrap().clone());
        let new_id = self.add(bytes);
        self.partitions[id] = self.partitions[new_id].clone();
        self.partitions.remove(new_id);
    }

    pub fn get(&self, id: usize) -> Vec<u8> {
        let range = self.partitions[id].clone();
        self.data[range].to_vec()
    }

    pub fn alloc(&mut self, additional: usize) {
        self.data.reserve(additional);
    }

    pub fn len(&self) -> usize {
        self.data.capacity()
    }
}

impl IntoIterator for MemoryHeap {
    type Item = Vec<u8>;
    type IntoIter = MemoryHeapIntoIterator;

    fn into_iter(self) -> Self::IntoIter {
        MemoryHeapIntoIterator {
            data: self.data.clone(),
            partitions: self.partitions.clone(),
            index: 0,
        }
    }
}

pub struct MemoryHeapIntoIterator {
    data: Vec<u8>,
    partitions: Vec<Range<usize>>,
    index: usize,
}

impl Iterator for MemoryHeapIntoIterator {
    type Item = Vec<u8>;

    fn next(&mut self) -> Option<Self::Item> {
        let index = self.index;
        self.index += 1;
        self.partitions.get(index).map(|range| self.data[range.clone()].to_vec())
    }
}

// Yes, I also asked for unit tests =)
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get() {
        let bytes = vec![1, 2, 3];
        let memory_heap = MemoryHeap {
            data: bytes.clone(),
            partitions: vec![0..3]
        };

        assert_eq!(memory_heap.get(0), bytes);
    }

    #[test]
    fn test_add() {
        let mut memory_heap = MemoryHeap::new(3);

        let bytes = vec![1, 2, 3];
        let id = memory_heap.add(bytes.clone());
        assert_eq!(memory_heap.get(id), bytes);
    }

    #[test]
    fn test_remove() {
        let mut memory_heap = MemoryHeap::new(3);

        let bytes = vec![1, 2, 3];
        let id = memory_heap.add(bytes.clone());
        memory_heap.remove(id);
        assert_eq!(memory_heap.data, Vec::<u8>::new());
    }

    #[test]
    fn test_edit() {
        let mut memory_heap = MemoryHeap::new(3);

        let bytes = vec![1, 2, 3];
        let id = memory_heap.add(bytes.clone());
        let new_bytes = vec![4, 5, 6];
        memory_heap.edit(new_bytes.clone(), id);
        println!("{memory_heap:?}");
        assert_eq!(memory_heap.get(id), new_bytes);
    }

    #[test]
    fn test_edit_bigger() {
        let mut memory_heap = MemoryHeap::new(3);

        let bytes = vec![1, 2, 3];
        let id = memory_heap.add(bytes.clone());
        let new_bytes = vec![4, 5, 6, 7];
        memory_heap.edit(new_bytes.clone(), id);
        println!("{memory_heap:?}");
        assert_eq!(memory_heap.get(id), new_bytes);
    }

    #[test]
    fn test_edit_smaller() {
        let mut memory_heap = MemoryHeap::new(3);

        let bytes = vec![1, 2, 3];
        let id = memory_heap.add(bytes.clone());
        let new_bytes = vec![4, 5];
        memory_heap.edit(new_bytes.clone(), id);
        println!("{memory_heap:?}");
        assert_eq!(memory_heap.get(id), new_bytes);
    }

    #[test]
    fn test_alloc() {
        let mut memory_heap = MemoryHeap::new(0);

        memory_heap.alloc(1024);
        assert_eq!(memory_heap.len(), 1024);
    }
}
