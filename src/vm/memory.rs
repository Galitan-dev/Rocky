use std::{
    io::{Cursor, Read},
    ops::Range,
};

use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};

// This file was originially generated by ChatGPT (after some discussion)

// I had given this struct
#[derive(Debug, Clone, PartialEq)]
pub struct MemoryHeap {
    data: Vec<u8>,
    partitions: Vec<Range<usize>>,
}

impl MemoryHeap {
    pub fn new(max_size: usize) -> Self {
        Self {
            data: Vec::with_capacity(max_size),
            partitions: Vec::new(),
        }
    }

    pub fn add(&mut self, bytes: Vec<u8>) -> usize {
        if self.data.len() + bytes.len() > self.data.capacity() {
            panic!("Memory heap exceeded maximum size");
        }
        let start = self.data.len();
        self.data.extend(bytes);
        let end = self.data.len();
        self.partitions.push(start..end);
        self.partitions.len() - 1
    }

    pub fn remove(&mut self, id: usize) {
        let range = &self.partitions.remove(id);
        self.delete(range.clone());
    }

    fn delete(&mut self, range: Range<usize>) {
        self.data.drain(range.clone());

        for partition in &mut self.partitions {
            if partition.start > range.end {
                *partition = partition.start - range.len()..partition.end - range.len();
            }
        }
    }

    // This was requested twice because the first time chatgpt didn't think about resizing partition
    pub fn edit(&mut self, bytes: Vec<u8>, id: usize) {
        if bytes.len() == self.get(id).len() {
            let range = self.partitions[id].clone();
            self.data.splice(range, bytes);
            return;
        }

        self.delete(self.partitions.get(id).unwrap().clone());
        let new_id = self.add(bytes);
        self.partitions[id] = self.partitions[new_id].clone();
        self.partitions.remove(new_id);
    }

    pub fn get(&self, id: usize) -> Vec<u8> {
        let range = self.partitions[id].clone();
        self.data[range].to_vec()
    }

    pub fn get_slice(&self, id: usize) -> &[u8] {
        let range = self.partitions[id].clone();
        &self.data[range]
    }

    pub fn alloc(&mut self, additional: usize) {
        self.data
            .reserve_exact(additional + self.data.capacity() - self.data.len());
    }

    pub fn len(&self) -> usize {
        self.data.capacity()
    }

    pub fn header(&self) -> Vec<u8> {
        let mut wtr = Vec::new();

        wtr.write_u32::<LittleEndian>(self.partitions.len() as u32 * 4)
            .unwrap();
        wtr.write_u32::<LittleEndian>(self.data.len() as u32)
            .unwrap();
        wtr.write_u32::<LittleEndian>(self.data.capacity() as u32)
            .unwrap();

        wtr
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut wtr = Vec::new();

        for range in &self.partitions {
            // wtr.write_u32::<LittleEndian>(range.start as u32).unwrap(); // needed if partitions move
            wtr.write_u32::<LittleEndian>(range.end as u32).unwrap();
        }

        wtr.append(&mut self.data.clone());

        wtr
    }

    pub fn from_bytes(bytes: &mut Cursor<&[u8]>, header: &mut Cursor<&[u8]>) -> Self {
        let num_partitions = header.read_u32::<LittleEndian>().unwrap() as usize / 4;
        let data_size = header.read_u32::<LittleEndian>().unwrap() as usize;
        let capacity = header.read_u32::<LittleEndian>().unwrap() as usize;

        let mut partitions = Vec::new();
        let mut current_start = 0;
        while partitions.len() < num_partitions {
            let next_start = bytes.read_u32::<LittleEndian>().unwrap() as usize;
            partitions.push(current_start..next_start);
            current_start = next_start;
        }

        let mut data: Vec<u8> = vec![0; data_size];
        bytes.read_exact(&mut data).unwrap();

        let mut sized: Vec<u8> = Vec::with_capacity(capacity);
        data.clone_into(&mut sized);

        Self {
            data: sized,
            partitions,
        }
    }
}

impl IntoIterator for MemoryHeap {
    type Item = Vec<u8>;
    type IntoIter = MemoryHeapIntoIterator;

    fn into_iter(self) -> Self::IntoIter {
        MemoryHeapIntoIterator {
            data: self.data.clone(),
            partitions: self.partitions.clone(),
            index: 0,
        }
    }
}

pub struct MemoryHeapIntoIterator {
    data: Vec<u8>,
    partitions: Vec<Range<usize>>,
    index: usize,
}

impl Iterator for MemoryHeapIntoIterator {
    type Item = Vec<u8>;

    fn next(&mut self) -> Option<Self::Item> {
        let index = self.index;
        self.index += 1;
        self.partitions
            .get(index)
            .map(|range| self.data[range.clone()].to_vec())
    }
}

// Yes, I also asked for unit tests =)
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get() {
        let bytes = vec![1, 2, 3];
        let memory_heap = MemoryHeap {
            data: bytes.clone(),
            partitions: vec![0..3],
        };

        assert_eq!(memory_heap.get(0), bytes);
    }

    #[test]
    fn test_add() {
        let mut memory_heap = MemoryHeap::new(3);

        let bytes = vec![1, 2, 3];
        let id = memory_heap.add(bytes.clone());
        assert_eq!(memory_heap.get(id), bytes);
    }

    #[test]
    fn test_remove() {
        let mut memory_heap = MemoryHeap::new(3);

        let bytes = vec![1, 2, 3];
        let id = memory_heap.add(bytes.clone());
        memory_heap.remove(id);
        assert_eq!(memory_heap.data, Vec::<u8>::new());
    }

    #[test]
    fn test_edit() {
        let mut memory_heap = MemoryHeap::new(3);

        let bytes = vec![1, 2, 3];
        let id = memory_heap.add(bytes.clone());
        let new_bytes = vec![4, 5, 6];
        memory_heap.edit(new_bytes.clone(), id);
        println!("{memory_heap:?}");
        assert_eq!(memory_heap.get(id), new_bytes);
    }

    #[test]
    fn test_edit_bigger() {
        let mut memory_heap = MemoryHeap::new(4);

        let bytes = vec![1, 2, 3];
        let id = memory_heap.add(bytes.clone());
        let new_bytes = vec![4, 5, 6, 7];
        memory_heap.edit(new_bytes.clone(), id);
        println!("{memory_heap:?}");
        assert_eq!(memory_heap.get(id), new_bytes);
    }

    #[test]
    fn test_edit_smaller() {
        let mut memory_heap = MemoryHeap::new(3);

        let bytes = vec![1, 2, 3];
        let id = memory_heap.add(bytes.clone());
        let new_bytes = vec![4, 5];
        memory_heap.edit(new_bytes.clone(), id);
        println!("{memory_heap:?}");
        assert_eq!(memory_heap.get(id), new_bytes);
    }

    #[test]
    fn test_alloc() {
        let mut memory_heap = MemoryHeap::new(0);

        memory_heap.alloc(1024);
        assert_eq!(memory_heap.len(), 1024);
    }

    #[test]
    fn to_bytes() {
        let memory_heap = MemoryHeap {
            data: vec![102, 18, 12, 152, 230, 56, 8, 2, 54, 0, 0, 1, 32],
            partitions: vec![0..2, 2..5, 5..8, 8..13],
        };

        assert_eq!(
            memory_heap.header(),
            vec![16, 0, 0, 0, 13, 0, 0, 0, 13, 0, 0, 0]
        );
        assert_eq!(
            memory_heap.to_bytes(),
            vec![
                2, 0, 0, 0, 5, 0, 0, 0, 8, 0, 0, 0, 13, 0, 0, 0, 102, 18, 12, 152, 230, 56, 8, 2,
                54, 0, 0, 1, 32
            ]
        );
    }

    #[test]
    fn from_bytes() {
        let memory_heap = MemoryHeap {
            data: vec![102, 18, 12, 152, 230, 56, 8, 2, 54, 0, 0, 1, 32],
            partitions: vec![0..2, 2..5, 5..8, 8..13],
        };

        let header = memory_heap.header();
        let bytes = memory_heap.to_bytes();
        let new_memory_heap =
            MemoryHeap::from_bytes(&mut Cursor::new(&bytes[..]), &mut Cursor::new(&header[..]));

        assert_eq!(new_memory_heap, memory_heap);
        assert_eq!(new_memory_heap.data.capacity(), memory_heap.data.capacity());
    }
}
